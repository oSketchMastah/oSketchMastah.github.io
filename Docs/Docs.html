
<!DOCTYPE html>
<html lang="en">
<!-- ******************************************************************** Head ********************************************************************** -->
<head>
	<title>MainIntelligence.org</title>
	<meta charset="utf-8">
  	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="Code Stuff">
	<meta name="keywords" content="programming, open, source, code, mainintelligence, docs">
	<meta property="og:title" content="MainIntelligence.org - C++ Code for the masses">
	<meta property="og:type" content="website">
	<!-- <meta property="og:image" content="ProjectFreeKnowledge.png"> -->
	<meta property="og:url" content="https://www.mainintelligence.org/Docs/Docs.html">
	<link rel="stylesheet" href="../navstyle.css">
	<link rel="stylesheet" href="../mainstyle.css">
	<link rel="shortcut icon" href="favicon.png" type="image/x-icon">
</head>
<!-- ******************************************************************** Body ********************************************************************** -->
<body>
<nav class="topnav">
	<div class="navClassCont">
		<p> Navigate </p>
		<div class="dropTopNav">
			<a href="Dependence.html"> Dependence </a>
		</div>
	</div>
	<div class="navClassCont">
		<a href="https://www.mainintelligence.org/"> Home </a>
	</div>
</nav>
<div class="main_title">
<h1>Docs</h1>
</div>
<p> Thinking about using MI in your code, or contributing to the project yourself? Want to better understand the structure of things, in terms of how we
	choose to segment our various libraries, how to use our types, etc.? </p>
	<p> Then you have come to the right place! (Welcome to the MI documentation space) </p>
	<p> If you're just trying to get a feel for the general style of things here, then allow me to introduce my general mindset:
		<ol>
		<hr>
		<li> I put a lot of time into designing the interface. I try and make the little things consistent. </li>
			<p> Things are meant to be at an intermediate level of abstration at which both usage and effect are somewhat obvious. </p>
		<hr>
		<li> I don't like being dependent on things I can't fix myself.</li>
			<p> There are situations where binary compatability is important. Keeping all dependencies maintainable within MI
				ensures I can avoid some future technical chaos, or at least be able to migrate libraries to updated versions
				when changes do occur. </p>
		<hr>
		<li> Sometimes I get scientific. </li>
			<p> Sometimes I try to do things in a way that's overly fanciful, then eventually decide there's a more practical way, and delete the original
				implementation, often eventually releasing something with slightly different semantics (and a different name) to do its purpose. 
				(ie. Might be worth checking the time-stamp on that last update, I could just be noodling, at least until we have a decent code-review process.) </p>
		<hr>
		<li> There are big plans! </li>
		<p> Eventually there are bigger systems that may be made publicly available at the MI repos. However much of the work resides in writing
			auxillary code that serves to make these systems manageable and highly maintainable from the beginning of their production. </p>
		<hr>
		</ol>
	</p>
	<p> It should be noted: </p>
	<ul> I don't care much for having unneccessary dependence. Most refined MI code does not rely on std namespace types, nor anything that isn't provided by MI.
		You should be able to find all of the interfaces provided in headers of our publicly available code within other publicly available MI repositories at 
		<a href="https://github.com/MainIntelligence"> github.com/MainIntelligence </a> </ul>
</body>

</html>
	
